<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GeoJSON Viewer</title>
<style>
  body, html {
    margin: 0; padding: 0; width: 100%; height: 100%;
    display: flex; justify-content: center; align-items: center;
    background: #f0f0f0;
  }
  svg {
    width: 90vw; height: 90vh;
    border: 1px solid #ccc;
    background: white;
  }
  path {
    fill: rgba(0, 128, 255, 0.5);
    stroke: blue;
    stroke-width: 1;
  }
</style>
</head>
<body>
  <svg id="map" viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg"></svg>

<script>
  // Convert longitude/latitude to SVG x/y (simple linear transform)
  // This is NOT a projection, just a bounding box fit
  function lonLatToXY([lon, lat], bounds, size) {
    const [minLon, minLat, maxLon, maxLat] = bounds;
    const x = ((lon - minLon) / (maxLon - minLon)) * size.width;
    const y = size.height - ((lat - minLat) / (maxLat - minLat)) * size.height;
    return [x, y];
  }

  // Find bounds of all coordinates in GeoJSON (simple bbox)
  function findBounds(geojson) {
    let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;

    function updateBounds(coords) {
      coords.forEach(coord => {
        if (Array.isArray(coord[0])) {
          updateBounds(coord);
        } else {
          const [lon, lat] = coord;
          if (lon < minLon) minLon = lon;
          if (lat < minLat) minLat = lat;
          if (lon > maxLon) maxLon = lon;
          if (lat > maxLat) maxLat = lat;
        }
      });
    }

    const type = geojson.type;

    if (type === 'FeatureCollection') {
      geojson.features.forEach(f => {
        updateBounds(f.geometry.coordinates);
      });
    } else if (type === 'Feature') {
      updateBounds(geojson.geometry.coordinates);
    } else {
      updateBounds(geojson.coordinates);
    }

    return [minLon, minLat, maxLon, maxLat];
  }

  // Create SVG path string from GeoJSON coordinates
  function coordsToPath(coords, bounds, size) {
    if (!coords.length) return '';

    // coords could be nested (for polygons with holes)
    if (typeof coords[0][0] === 'number') {
      // Simple ring of points
      const points = coords.map(coord => lonLatToXY(coord, bounds, size));
      return points.reduce((acc, [x, y], i) => 
        acc + (i === 0 ? 'M' : 'L') + x.toFixed(2) + ' ' + y.toFixed(2), '') + 'Z';
    } else {
      // Multi-ring or MultiPolygon
      return coords.map(ring => coordsToPath(ring, bounds, size)).join(' ');
    }
  }

  function renderGeoJSON(geojson) {
    const svg = document.getElementById('map');
    svg.innerHTML = ''; // clear

    const size = { width: 1000, height: 1000 };
    const bounds = findBounds(geojson);

    function drawFeature(feature) {
      const geom = feature.geometry;
      let pathStr = '';

      switch (geom.type) {
        case 'Polygon':
          pathStr = coordsToPath(geom.coordinates, bounds, size);
          break;
        case 'MultiPolygon':
          pathStr = geom.coordinates.map(polygon => coordsToPath(polygon, bounds, size)).join(' ');
          break;
        case 'LineString':
          pathStr = coordsToPath(geom.coordinates, bounds, size);
          break;
        case 'MultiLineString':
          pathStr = geom.coordinates.map(line => coordsToPath(line, bounds, size)).join(' ');
          break;
        case 'Point':
          // Render as circle
          const [cx, cy] = lonLatToXY(geom.coordinates, bounds, size);
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', cx);
          circle.setAttribute('cy', cy);
          circle.setAttribute('r', 5);
          circle.setAttribute('fill', 'red');
          svg.appendChild(circle);
          return;
        case 'MultiPoint':
          geom.coordinates.forEach(coord => {
            const [cx, cy] = lonLatToXY(coord, bounds, size);
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', cx);
            circle.setAttribute('cy', cy);
            circle.setAttribute('r', 5);
            circle.setAttribute('fill', 'red');
            svg.appendChild(circle);
          });
          return;
        default:
          console.warn('Unsupported geometry type:', geom.type);
          return;
      }

      if (pathStr) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathStr);
        svg.appendChild(path);
      }
    }

    if (geojson.type === 'FeatureCollection') {
      geojson.features.forEach(drawFeature);
    } else if (geojson.type === 'Feature') {
      drawFeature(geojson);
    } else {
      // Bare geometry
      drawFeature({geometry: geojson});
    }
  }

  // Load the geojson file
  fetch('/map.geojson')
    .then(res => res.json())
    .then(data => renderGeoJSON(data))
    .catch(err => {
      document.body.textContent = 'Failed to load GeoJSON: ' + err;
    });

</script>
</body>
</html>
